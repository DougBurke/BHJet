#define HAVE_LONG_LONG 1
/* * This file was generated by SLIRP, the (Sl)ang (I)nte(r)face (P)ackage,
 * a S-Lang module code generator for C, C++, and FORTRAN.
 *
 * Copyright (C) 2003-2009 Massachusetts Institute of Technology 
 * Copyright (C) 2002 Michael S. Noble <mnoble@space.mit.edu>
 *
 * SLIRP is free software, and may be used under the conditions stipulated
 * in the COPYRIGHT agreement bundled within the SLIRP distribution.
 */
#include <stdlib.h>		/* SLIRP common {{{ */
#include <unistd.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>
#include <slang.h>

#define SAFE_DEREF_OPAQUE(po)		(po == NULL ? NULL : po->instance)
#define SAFE_DEREF_ARRAY(pa)		(pa == NULL ? NULL : pa->data)
#define SLang_pop_array(x)		SLang_pop_array(x, 1)
#define SLang_pop_string(x)             ( (SLang_peek_at_stack() == SLANG_NULL_TYPE && (SLdo_pop() || 1)) ? ((*x = NULL) || 1): SLang_pop_slstring(x))
#define SLang_push_size_t		SLang_push_ulong
#define SLang_push_ptrdiff_t		SLang_push_long

#define pop_defaultable(argno, kind, type, obj, value) \
   (SLang_Num_Function_Args >= argno ? SLang_pop_##kind ( (type*)&obj) : ((obj = value) || ( (void*)&obj > (void*)0) ) )

#ifdef __cplusplus
#define LINKAGE "C"
#else
#define LINKAGE
#endif

#define USAGE(msg) \
    {SLang_verror(SL_USAGE_ERROR, (char*)"Usage: %s", msg); return;}

static void Slirp_usage(int i, int j, int flags);

static int slang_abi_mismatch(void)
{
   long module_abi = SLANG_VERSION / 10000;
   long app_abi    = SLang_Version / 10000;

   if (module_abi != app_abi) {
	SLang_verror(SL_APPLICATION_ERROR, (char*)
		"S-Lang library abi mismatch\nmodule: %s, application: %s",
		SLANG_VERSION_STRING, SLang_Version_String);
	return 1;
   }
			        
   return 0;
} /* }}} */

static char *slns;  /* slang namespace active at time of module load */
#include "agnjet_merged.hh"
#define OBJECT(o)			SAFE_DEREF_OPAQUE(o)
#define BEGIN_DECLS			extern "C" {
#define END_DECLS			}
#define SLIRP_EXTERN
BEGIN_DECLS				/* Opaque handling code {{{ */

#define SLIRP_ABI_VERSION			10500

typedef void            (*FINALIZER)            (void*);
typedef void            (*INITIALIZER)          (void*);

typedef struct _Slirp_Type {
   SLang_Class_Type	*slclass;	/* SLang type class for this type */
   struct _Slirp_Type	*parent;	/* NULL if type has no ancestors  */
   FINALIZER		finalizer;
   INITIALIZER		initializer;
} Slirp_Type;

typedef struct _Slirp_Opaque {
   Slirp_Type *type;
   SLang_MMT_Type *mmt;
   void* instance;
   int deletion_in_progress;
   int free_me_too;		       /* if non-zero, free MMT, then struct */
   int owns_ref;		       /* if non-zero, do not free instance */
} Slirp_Opaque;

static void SLang_free_opaque (Slirp_Opaque *o)
{
   SLang_MMT_Type *mmt;

   if ((o == NULL)
       || (o->deletion_in_progress))
     return;

   mmt = o->mmt;
   if (mmt == NULL)
     return;

   o->mmt = NULL;
   o->deletion_in_progress = 1;
   SLang_free_mmt (mmt);
   o->deletion_in_progress = 0;
   if (o->free_me_too)
     SLfree ((char *) o);
}


static int opaque_typecast (SLtype from_type, VOID_STAR from_p,
			unsigned int num, SLtype to_type, VOID_STAR to_p)
{
   unsigned int i;
   SLang_MMT_Type **from = (SLang_MMT_Type**)from_p;
   SLang_MMT_Type **to   = (SLang_MMT_Type**)to_p;

   (void) from_type; (void) to_type; 

   for (i=0; i < num; i++) {
	to[i] = from[i];	/* FIXME: typeof() still reports prev type */
	if (from[i] != NULL)
	   SLang_inc_mmt(from[i]);
   }

   return 1;
}

static int opaque_search(const void* key, const void *elem)
{
   return *(SLtype*)key - SLclass_get_class_id((*(Slirp_Type**)elem)->slclass);
}

static void destroy_opaque(SLtype type, VOID_STAR w)
{
   Slirp_Opaque *ot = (Slirp_Opaque*)w;

   (void) type;

   if ((ot->type != NULL)
       && (ot->type->finalizer != NULL)
       && (ot->instance != NULL))
     {
	if (ot->owns_ref == 0)
	  (*ot->type->finalizer) (ot->instance);
	ot->instance = NULL;
     }

   if (ot->deletion_in_progress)
     {
	/* Evidently, the MMT container is being destroyed from SLang_free_mmt.
	 * Let it perform the final free.
	 */
	ot->free_me_too = 1;
	return;
     }
   SLfree( (char*)ot );
}
END_DECLS

SLIRP_EXTERN SLtype void_ptr_Type;	/* These opaque pointer types must */
SLIRP_EXTERN SLtype string_ptr_Type;	/* be kept in sync with opaques.c  */
SLIRP_EXTERN SLtype uchar_ptr_Type;
SLIRP_EXTERN SLtype short_ptr_Type;
SLIRP_EXTERN SLtype ushort_ptr_Type;
SLIRP_EXTERN SLtype int_ptr_Type;
SLIRP_EXTERN SLtype uint_ptr_Type;
SLIRP_EXTERN SLtype long_ptr_Type;
SLIRP_EXTERN SLtype ulong_ptr_Type;
SLIRP_EXTERN SLtype float_ptr_Type;
SLIRP_EXTERN SLtype double_ptr_Type;
SLIRP_EXTERN SLtype opaque_ptr_Type;
SLIRP_EXTERN SLtype file_ptr_Type;

typedef struct _Reserved_Opaque_Type {
   char	  *name;
   SLtype *type;		/* SLtype of opaque pointer defined by this */
   SLtype masked_type;		/* SLtype of datum to which this points */
} Reserved_Opaque_Type;

SLIRP_EXTERN Slirp_Type	**Slirp_Opaque_Types;
SLIRP_EXTERN SLtype 	Slirp_Num_Opaque_Types;
SLIRP_EXTERN SLtype	First_Opaque_Type;
SLIRP_EXTERN SLtype	Last_Reserved_Opaque_Type;

static Reserved_Opaque_Type Reserved_Opaque_Types[] = {

   { (char*)"void_ptr",		&void_ptr_Type,		SLANG_ANY_TYPE,    },
   { (char*)"int_ptr",		&int_ptr_Type,		SLANG_INT_TYPE,    },
   { (char*)"double_ptr",	&double_ptr_Type,	SLANG_DOUBLE_TYPE, },
   { (char*)"opaque_ptr",	&opaque_ptr_Type,	SLANG_ANY_TYPE,	   },
   { (char*)"file_ptr",		&file_ptr_Type,		SLANG_FILE_PTR_TYPE,},
   { (char*)"float_ptr",	&float_ptr_Type,	SLANG_FLOAT_TYPE,  },
   { (char*)"long_ptr",		&long_ptr_Type,		SLANG_LONG_TYPE,   },
   { (char*)"string_ptr",	&string_ptr_Type,	SLANG_STRING_TYPE, },
   { (char*)"uint_ptr",		&uint_ptr_Type,		SLANG_UINT_TYPE,   },
   { (char*)"short_ptr",	&short_ptr_Type,	SLANG_SHORT_TYPE,  },
   { (char*)"ulong_ptr",	&ulong_ptr_Type,	SLANG_ULONG_TYPE,  },
   { (char*)"ushort_ptr",	&ushort_ptr_Type,	SLANG_USHORT_TYPE, },
   { (char*)"uchar_ptr",	&uchar_ptr_Type,	SLANG_UCHAR_TYPE,  },
   { NULL, NULL, 0, }
};

#define NUM_RESERVED_OPAQUES \
	sizeof(Reserved_Opaque_Types) / sizeof(Reserved_Opaque_Type) - 1

static Slirp_Type* sltype_to_slirp_type(SLtype sltype)
{
   Slirp_Type **ot = (Slirp_Type**) bsearch( (const void*) &sltype,
	 		(const void*) Slirp_Opaque_Types,
			(size_t) Slirp_Num_Opaque_Types,
			sizeof(Slirp_Type*), opaque_search);

   if (ot != NULL) return *ot;
   return NULL;
}

static SLang_MMT_Type*
create_opaque_mmt(SLtype type, void *instance, unsigned int owns_ref)
{
   SLang_MMT_Type *mmt = NULL;
   Slirp_Opaque *ot = (Slirp_Opaque*) SLcalloc(1, sizeof(Slirp_Opaque));

   if (ot != NULL) {

	ot->instance = instance;
	ot->owns_ref = owns_ref;
	ot->mmt      = NULL;

	if ( (ot->type = sltype_to_slirp_type(type)) != NULL) {

	   if (ot->type->initializer != NULL)
		(*ot->type->initializer) (ot->instance);

	   mmt = SLang_create_mmt (type, (VOID_STAR) ot);
	}

	if (mmt == NULL)
	   SLfree((char*)ot);
   }

   return mmt;
}

static int SLang_push_opaque(SLtype type, void *instance, unsigned int owns_ref)
{
   SLang_MMT_Type *mmt;

   if (instance == NULL)
      return SLang_push_null();

   mmt = create_opaque_mmt(type, instance, owns_ref);
   if (NULL == mmt)
      return -1;

   if (-1 == SLang_push_mmt (mmt))
     {
	SLang_free_mmt (mmt);
	return -1;
     }
   return 0;
}

static int SLang_pop_opaque (SLtype type, void **instance, Slirp_Opaque **o)
{
   Slirp_Opaque *ot;
   SLang_MMT_Type *mmt = NULL;

   if (instance != NULL) *instance = NULL;
   *o = NULL;

   if ((type == file_ptr_Type)
       && (SLang_peek_at_stack() == SLANG_FILE_PTR_TYPE))
     {
	FILE *fp;
	if (-1 == SLang_pop_fileptr(&mmt, &fp))
	  return -1;

	ot = (Slirp_Opaque*) SLcalloc(1, sizeof(Slirp_Opaque));
	if (ot == NULL)
	  {
	     SLang_free_mmt(mmt);
	     return -1;
	  }
	ot->mmt = mmt;
	ot->free_me_too = 1;
	*instance = (void*)fp;
	*o = ot;
	return 0;
   }

   if (NULL == (mmt = SLang_pop_mmt (type)))
     return -1;

   if (NULL == (ot = (Slirp_Opaque*) SLang_object_from_mmt (mmt))
       || (ot->instance == NULL))
     {
	SLang_verror (SL_INVALID_PARM, "%s", "slirp: pop_opaque: instance=NULL");
	SLang_free_mmt (mmt);
	return -1;
     }

   /* This creates a circular reference:
    *    mmt->ot->mmt
    */
   ot->mmt = mmt;
   if (instance != NULL)
     *instance = ot->instance;
   *o = ot;
   return 0;
}

static unsigned int
allocate_opaque(char *name, FINALIZER fzer, INITIALIZER izer, SLtype parent_id,
		int (*sget)(SLtype, char *), int (*sput)(SLtype, char *))
{
   /* Returning from here with anything but a positive id is fatal */
   SLtype new_type, ancestor_type;
   Slirp_Type *type , *parent = NULL;
   SLang_Class_Type *new_class = SLclass_allocate_class (name);

   if (new_class == NULL) return SLANG_UNDEFINED_TYPE;

   (void) SLclass_set_destroy_function (new_class, destroy_opaque);
   if (-1 == SLclass_register_class (new_class, SLANG_VOID_TYPE,
				     sizeof(Slirp_Opaque),
				     SLANG_CLASS_TYPE_MMT))
	return SLANG_UNDEFINED_TYPE;

   new_type = SLclass_get_class_id(new_class);
   if (parent_id) {

	type = parent = sltype_to_slirp_type(parent_id);

	while (type) {

	   ancestor_type = SLclass_get_class_id(type->slclass);

	   /* Support downcasting ancestor types to this type */
	   if (-1 == SLclass_add_typecast (ancestor_type, new_type,
		    					opaque_typecast, 1))
		return SLANG_UNDEFINED_TYPE;

	   /* Support upcasting this type to each ancestor type */
	   if (-1 == SLclass_add_typecast (new_type, ancestor_type,
							opaque_typecast, 1))
		return SLANG_UNDEFINED_TYPE;

	   type = type->parent;
	}
   }

   if ( (sget != NULL && SLclass_set_sget_function(new_class, sget) == -1) ||
	(sput != NULL && SLclass_set_sput_function(new_class, sput) == -1))
	return SLANG_UNDEFINED_TYPE;
	
   if ( (type = (Slirp_Type*) SLmalloc(sizeof(Slirp_Type))) == NULL)
	return SLANG_UNDEFINED_TYPE;

   type->slclass = new_class;
   type->parent = parent;
   type->finalizer = fzer;
   type->initializer = izer;
   Slirp_Opaque_Types[ Slirp_Num_Opaque_Types++ ] = type;

   return new_type;
}

static int allocate_reserved_opaque_types(void)
{
   Reserved_Opaque_Type *pt;
   long abi_version = -1;

   if ( SLang_is_defined((char*)"_slirp_initialized")) {

	if ( SLang_is_defined((char*)"_slirp_abi_version") == 0  ||
		SLang_load_string((char*)"_slirp_abi_version;") == -1 ||
		SLang_pop_long(&abi_version) == -1 ||
		abi_version != SLIRP_ABI_VERSION)
	{
	   SLang_verror(SL_APPLICATION_ERROR,
		(char*) "SLIRP abi mismatch: want version %ld, have %ld\n",
		(long)SLIRP_ABI_VERSION, abi_version);
	   return -1;
	}

	return 0;
   }

   (void)SLang_load_string((char*)"public variable _slirp_initialized=1;");
   (void)SLang_push_int(SLIRP_ABI_VERSION);
   (void)SLang_load_string((char*)"public variable _slirp_abi_version=();");

   Slirp_Num_Opaque_Types = 0;

   if ( NULL == (Slirp_Opaque_Types = (Slirp_Type**) SLmalloc
			( sizeof(Slirp_Type*) * (NUM_RESERVED_OPAQUES + 1))))
      return -1;

   Slirp_Opaque_Types[0] = NULL;

   pt = Reserved_Opaque_Types;
   while (pt->name != NULL) {
	if ((*pt->type = allocate_opaque(pt->name, NULL,NULL,0,NULL,NULL)) ==
	      						SLANG_UNDEFINED_TYPE)
		return -1;
	   pt++;
	}

   /* Loop again, to enable casts to/from generic pointer type */
   pt = Reserved_Opaque_Types + 1;
   while (pt->name != NULL) {

	if (-1 == SLclass_add_typecast (*pt->type, void_ptr_Type,
							opaque_typecast, 1))
	   return SLANG_UNDEFINED_TYPE;

	if (-1 == SLclass_add_typecast (void_ptr_Type, *pt->type,
							opaque_typecast, 1))
	   return SLANG_UNDEFINED_TYPE;

	pt++;
   }

   First_Opaque_Type = *Reserved_Opaque_Types[0].type;
   Last_Reserved_Opaque_Type = First_Opaque_Type + NUM_RESERVED_OPAQUES - 1;

   return 0;
} /* }}} */

SLtype gsl_spline_ptr_Type = 0;
SLtype gsl_interp_accel_ptr_Type = 0;

static int allocate_agnjet_merged_opaque_types(void) /* {{{ */
{
   if (gsl_spline_ptr_Type) return 0;

   Slirp_Opaque_Types = (Slirp_Type**) SLrealloc((char*)Slirp_Opaque_Types,
		(1 + Slirp_Num_Opaque_Types + 2) * sizeof(Slirp_Type*));

   if (Slirp_Opaque_Types == NULL) return -1;

   gsl_spline_ptr_Type = allocate_opaque((char*)"gsl_spline_ptr_Type",
		(FINALIZER) NULL, 
		(INITIALIZER) NULL,
		(SLtype) void_ptr_Type, NULL, NULL);
   if (gsl_spline_ptr_Type == SLANG_UNDEFINED_TYPE) return -1;

   gsl_interp_accel_ptr_Type = allocate_opaque((char*)"gsl_interp_accel_ptr_Type",
		(FINALIZER) NULL, 
		(INITIALIZER) NULL,
		(SLtype) void_ptr_Type, NULL, NULL);
   if (gsl_interp_accel_ptr_Type == SLANG_UNDEFINED_TYPE) return -1;

   return 0;
} /* }}} */
static unsigned char map_scalars_to_refs = 0;

typedef struct _Slirp_Ref {			/* Ref handling code {{{ */
#define	REF_FLAG_FREE_DATA			0x01
#define	REF_FLAG_IS_OPAQUE			0x02
#define	REF_FLAG_COLUMN_MAJOR			0x04
#define	REF_FLAG_ARRAY_EXPECTED			0x08
   unsigned int		flags;		/* Slirp_Ref encapsulates S-Lang    */
   SLtype		sltype;		/* array, ref, and MMT types, the   */
   size_t		sizeof_type;	/* latter two of which are seen as  */
   void			**data;		/* pointing to a single object      */
   unsigned int		vstride;	/* how to find "next" vectored elem */
   SLang_Array_Type	*array;
   SLang_Ref_Type	*ref;
   SLang_MMT_Type	*mmt;		/* mmt supports passing around C    */
} Slirp_Ref;				/* ptr arrays of indeterminate size */

static Slirp_Ref* ref_new(SLtype t,size_t typesize, void *d,unsigned int flags)
{
   Slirp_Ref *ref;
   if ((ref = (Slirp_Ref*)SLcalloc( sizeof(Slirp_Ref), 1)) != NULL) {
	ref->sltype = t;
	ref->sizeof_type = typesize;
	ref->flags = flags;
	ref->data = (void**)d;
	*ref->data = NULL;
   }
   return ref;
}

static int ref_finalize(Slirp_Ref *r) /* {{{ */
{
   int status = 0;
   if (r == NULL) return 0;

   if (r->ref) {

        void *ref_value = NULL; SLtype ref_type = 0; double dc[2];

	if (r->flags & REF_FLAG_IS_OPAQUE) { 	/* wrap aggregates/opaques  */
#ifdef NUM_RESERVED_OPAQUES			/* in mmt before ref assign */
	   void *opaqval = *r->data;		/* the mmt w/be freed when  */
	   if (opaqval == NULL) {		/* the S-Lang object goes   */
		ref_value = NULL;		/* out of scope		    */
		ref_type = SLANG_NULL_TYPE;
	   }
	   else {
		SLang_MMT_Type *mmt = create_opaque_mmt(r->sltype, opaqval, 0);
		ref_value = &mmt;
		ref_type = r->sltype;
	   }
#endif
	}
	else {
	   ref_type = r->sltype;
	   if (ref_type == SLANG_COMPLEX_TYPE && r->sizeof_type < sizeof(dc)) {
		float *fc = (float*) r->data;
		dc[0] = fc[0];
		dc[1] = fc[1];
		ref_value = dc;
	   }
	   else
		ref_value = r->data;
	}

	status = SLang_assign_to_ref (r->ref, ref_type, ref_value);
	SLang_free_ref(r->ref);
   }
   else if (r->array) {
#ifdef HAVE_FORTRAN_CODE
	if ((r->flags & REF_FLAG_COLUMN_MAJOR) && TRANSPOSE(1,r->array) == -1)
		return -1;
#endif
	SLang_free_array(r->array);
   }
   else if (r->mmt)
	SLang_free_mmt(r->mmt);

   if (r->flags & REF_FLAG_FREE_DATA)
	SLfree( (char*) r->data );

   SLfree((char*)r);
   return status;
} /* }}} */

static void finalize_refs(unsigned int nargs, ...) /* {{{ */
{
   va_list ap;
   va_start(ap, nargs);
   while (nargs--) ref_finalize(va_arg(ap, Slirp_Ref *));
   va_end(ap);
} /* }}} */

static unsigned int ref_get_size(Slirp_Ref *r, int which_dimension) /* {{{ */
{
   if (r->array) {
	if (which_dimension == 0)
	   return (unsigned int)r->array->num_elements;
	else if (which_dimension < 0)
	   return r->array->num_dims;
	else {
	   which_dimension--;
	   if ((unsigned int)which_dimension < r->array->num_dims)
		return (unsigned int)r->array->dims[which_dimension];
	   else
		return 0;
	}
   }

   return 1;
} /* }}} */

extern LINKAGE int _SLang_get_class_type (SLtype t);	/* quasi-public  */

#ifdef NUM_RESERVED_OPAQUES
static SLtype sltype_to_opaque_ptr_type(SLtype sltype) /*{{{*/
{
   Reserved_Opaque_Type *pt;

   if (sltype > Last_Reserved_Opaque_Type) return opaque_ptr_Type;
   if (sltype == void_ptr_Type) return void_ptr_Type;

   pt = Reserved_Opaque_Types;		/* sequential search, but s/b < O(n) */
   while (pt->name) {			/* since list is ordered by expected */
	if (pt->masked_type == sltype)	/* frequency of use for each SLtype  */
	   return *pt->type;		
	pt++;
   }
   return 0;
} /*}}}*/
#endif

static int try_pop_mmt(SLtype type, SLang_MMT_Type **mmt) /*{{{*/
{
   static SLang_Name_Type *cl_type_func;	/* SLang_pop_mmt doesn't */
   int classtype;				/* validate that type is */
						/* an MMT, so we do here */
   *mmt = NULL;					/* FIXME: remove v2.0.7  */

   if (cl_type_func == NULL)
	cl_type_func = SLang_get_function( (char*) "__class_type");

   if (cl_type_func == NULL)
      return 0;

   if (-1 == SLang_push_datatype(type) ||		/* do the hard way, */
	-1 == SLexecute_function(cl_type_func) ||	/* as C api lacks   */
	-1 == SLang_pop_int(&classtype))		/* get_class_type() */
	return -1;

   if (classtype == SLANG_CLASS_TYPE_MMT) {
	*mmt = SLang_pop_mmt(type);
	return 1;
   }
   return 0;
} /*}}}*/

#define POP_FLAG_NULLABLE	0x1
#define POP_FLAG_VECTORIZE	0x2
static int pop_array_or_ref(Slirp_Ref *r, int flags, int defaultable) /*{{{*/
{
   SLtype type;
   unsigned int i, objtype;
#ifdef NUM_RESERVED_OPAQUES
   unsigned int is_opaque;
#endif

   if (r == NULL) {
	SLang_verror(SL_INTRINSIC_ERROR, (char*)"Attempted NULL reference (out of memory?)");
	return -1;
   }

   if (defaultable && SLang_Num_Function_Args < defaultable) {
	r->ref   = NULL;	/* observe that only NULL can be */
	*r->data = NULL;	/* assigned as the default value */
	return 0;
   }
   
   objtype = SLang_peek_at_stack();

   if ((flags & POP_FLAG_NULLABLE) && objtype == SLANG_NULL_TYPE) {
	r->ref   = NULL;		/* nullable flag: a pointer arg for */
	*r->data = NULL;		/* which NULL is a legitimate value */
	return SLang_pop_null ();
   }

   type = r->sltype;

#ifdef NUM_RESERVED_OPAQUES
   is_opaque =(type >= First_Opaque_Type && sltype_to_slirp_type(type) != NULL);
   if (is_opaque) r->flags |= REF_FLAG_IS_OPAQUE;
#endif

   switch(objtype) {

	case SLANG_ARRAY_TYPE:

	   if (SLang_pop_array_of_type(&r->array, type) == -1)
		return -1;

#ifdef HAVE_FORTRAN_CODE
	   if (r->flags & REF_FLAG_COLUMN_MAJOR) {
		if (flags & POP_FLAG_VECTORIZE)		/* vectorizable arrs*/
		   r->flags ^= REF_FLAG_COLUMN_MAJOR;   /* r not transposed */
		else if (TRANSPOSE(0,r->array) == -1)
		   return -1;
	   }
#endif

	   i = r->array->num_elements;
#ifdef NUM_RESERVED_OPAQUES
	   if (is_opaque) {
	      	Slirp_Opaque *ot;
		SLang_MMT_Type** mmts = (SLang_MMT_Type**)r->array->data;
		void **arr = (void**)SLmalloc(i * sizeof(void*) );
		if (arr == NULL) return -1;

		while (i--) {
		   ot = (Slirp_Opaque*) SLang_object_from_mmt (mmts[i]);
		   if (ot == NULL) {
			SLfree((char*)arr);
			return -1;
		   }
		   arr[i] = ot->instance;
		}

		*r->data = (void*)arr; r->data = (void**)arr;
		r->flags |= REF_FLAG_FREE_DATA;
	   }
	   else
#endif
	   if (type == SLANG_COMPLEX_TYPE &&
		 		r->sizeof_type < r->array->sizeof_type) {
		double *dc = (double*) r->array->data;
		float  *fc = (float *) SLmalloc(i * r->sizeof_type);
		if (fc == NULL) return -1;
		*r->data = fc; r->data = (void**)fc;
		while (i--) { *fc++ = (float) *dc++; *fc++ = (float) *dc++; }
		r->flags |= REF_FLAG_FREE_DATA;
	   }
	   else {
		*r->data = r->array->data;
		r->data = (void**)*r->data;
	   }

	   break;

	case SLANG_REF_TYPE:

	   /* Refs can only send values one-way (C to S-Lang, not reverse) */
	   if (SLang_pop_ref(&r->ref) == -1)
		return -1;

	   /* Ref is assumed to point to a scalar instance of the  */
	   /* refd type, so declare enough space to hold one such. */
	   *r->data = (void*)SLmalloc(r->sizeof_type);
	   if (*r->data == NULL) return -1;
	   memset(*r->data, 0, r->sizeof_type);
	   r->flags |= REF_FLAG_FREE_DATA;
	   r->data = (void**)*r->data;
	   break;

	/* Allow scalars to used as if they were 1-element arrays */
	case SLANG_CHAR_TYPE: case SLANG_UCHAR_TYPE:
	case SLANG_SHORT_TYPE: case SLANG_USHORT_TYPE:
	case SLANG_INT_TYPE: case SLANG_UINT_TYPE:
	case SLANG_LONG_TYPE: case SLANG_ULONG_TYPE:
	case SLANG_FLOAT_TYPE: case SLANG_DOUBLE_TYPE:
	case SLANG_COMPLEX_TYPE: case SLANG_STRING_TYPE:

	   /* Accomodate FORTRAN-style pass by reference semantics */
	   if (map_scalars_to_refs &&
		 	SLang_pop_array_of_type(&r->array,type) == 0) {

		*r->data = (void*)SLmalloc(r->sizeof_type);
		if (*r->data == NULL) return -1;

		if (r->sizeof_type == r->array->sizeof_type)
		   memcpy(*r->data, r->array->data, r->sizeof_type);
		else if (type == SLANG_COMPLEX_TYPE) {
		   double *dc = (double*) r->array->data;
		   float  *fc = (float*) *r->data;
		   fc[0] = (float)dc[0];
		   fc[1] = (float)dc[1];
		}
		else  {
		   SLang_verror(SL_TYPE_MISMATCH, (char*)
			"mismatched type sizes, when popping scalar as ref");
		   SLang_free_array(r->array);
		   return -1;
		}

		r->data = (void**)*r->data;
		r->flags |= REF_FLAG_FREE_DATA;
		/* Nullify to distinguish between vectored/non-vectored args */
		SLang_free_array(r->array); r->array = NULL;
		break;
	   }				/* intentional fallthrough */

	default:

#ifdef NUM_RESERVED_OPAQUES
	   if (objtype >= First_Opaque_Type && 
		 		sltype_to_slirp_type(objtype) != NULL) {

		if (!(flags & POP_FLAG_VECTORIZE))
		   type = sltype_to_opaque_ptr_type(type);

		if (type) {

		   Slirp_Opaque *otp;
		   if (SLang_pop_opaque(type, NULL, &otp) == -1)
			return -1;
		
		   if (flags & POP_FLAG_VECTORIZE) {
			void **arr = (void**) SLmalloc(sizeof(void*));
			if (arr == NULL) return -1;
			arr[0] = otp->instance;
			*r->data = arr;
			r->flags |= REF_FLAG_FREE_DATA;
		   }
		   else
			*r->data = otp->instance;

		   r->data = (void**)*r->data;
		   r->mmt = otp->mmt;
		   return 0;
		}
	   }
	   else
#endif
	   if ( try_pop_mmt(objtype, &r->mmt) == 1 &&
		(*r->data = SLang_object_from_mmt (r->mmt)) != NULL) {
		   r->data = (void**)*r->data;	 /* not flagged for freeing */
		   return 0;
	   }

	   SLang_verror(SL_TYPE_MISMATCH, (char*)
			"context requires array, ref, or opaque pointer");
	   return -1;
   }
   return 0;
} /*}}}*/
/* }}} */

/* Wrapper functions */ /* {{{ */
static void dispatch (int first, int stop, int usage, int v);
static void sl_k3_fnc (void)
{
   double retval;
   double arg1;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   retval = k3_fnc( arg1);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (0, 0, 0);
}

static void sl_xrbjet (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   int arg2;
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   double* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg5,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 5) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg2)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   xrbjet(arg1,  arg2, arg3, arg4, arg5);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (1, 1, 0);
   finalize_refs(4,arg1_r,arg3_r,arg4_r,arg5_r); 
}

static void sl_k2_fnc (void)
{
   double retval;
   double arg1;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   retval = k2_fnc( arg1);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (2, 2, 0);
}

static void sl_bbintegrals (void)
{
   double arg1;
   double arg2;
   double arg3;
   double arg4;
   double arg5;
   double arg6;
   double arg7;
   double arg8;
   double arg9;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 9) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg9)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg8)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg7)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg6)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg5)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg4)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg3)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg2)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   bbintegrals( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (3, 3, 0);
}

static void sl_xrbinterp (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   int arg5;
   int arg6;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 6) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg6)) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg5)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   xrbinterp(arg1, arg2, arg3, arg4,  arg5,  arg6);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (4, 4, 0);
   finalize_refs(4,arg1_r,arg2_r,arg3_r,arg4_r); 
}

static void sl_b_prof (void)
{
   double arg1;
   double arg2;
   double arg3;
   double arg4;
   double arg5;
   double arg6;
   double arg7;
   double arg8;
   double arg9;
   double arg10;
   double arg11;
   double arg12;
   double arg13;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 13) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg13)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg12)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg11)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg10)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg9)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg8)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg7)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg6)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg5)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg4)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg3)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg2)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   b_prof( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11,  arg12,  arg13);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (5, 5, 0);
}

static void sl_jetpars (void)
{
   double arg1;
   double arg2;
   double arg3;
   double arg4;
   double arg5;
   double arg6;
   double arg7;
   double arg8;
   double arg9;
   double arg10;
   double arg11;
   gsl_spline* arg12;
   Slirp_Opaque* arg12_o = NULL;
   gsl_interp_accel* arg13;
   Slirp_Opaque* arg13_o = NULL;
   double arg14;
   double arg15;
   double arg16;
   double arg17;
   double arg18;
   double arg19;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 19) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg19)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg18)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg17)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg16)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg15)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg14)) goto usage_label;
   if (-1 == SLang_pop_opaque(gsl_interp_accel_ptr_Type, (void**)&arg13, &arg13_o)) goto usage_label;
   if (-1 == SLang_pop_opaque(gsl_spline_ptr_Type, (void**)&arg12, &arg12_o)) goto free_and_return_13;
   if (-1 == SLang_pop_double((double*)&arg11)) goto free_and_return_12;
   if (-1 == SLang_pop_double((double*)&arg10)) goto free_and_return_12;
   if (-1 == SLang_pop_double((double*)&arg9)) goto free_and_return_12;
   if (-1 == SLang_pop_double((double*)&arg8)) goto free_and_return_12;
   if (-1 == SLang_pop_double((double*)&arg7)) goto free_and_return_12;
   if (-1 == SLang_pop_double((double*)&arg6)) goto free_and_return_12;
   if (-1 == SLang_pop_double((double*)&arg5)) goto free_and_return_12;
   if (-1 == SLang_pop_double((double*)&arg4)) goto free_and_return_12;
   if (-1 == SLang_pop_double((double*)&arg3)) goto free_and_return_12;
   if (-1 == SLang_pop_double((double*)&arg2)) goto free_and_return_12;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_12;
   issue_usage = 0;

   jetpars( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11, arg12, arg13,  arg14,  arg15,  arg16,  arg17,  arg18,  arg19);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_12:
   SLang_free_opaque(arg12_o);
free_and_return_13:
   SLang_free_opaque(arg13_o);
usage_label:
   if (issue_usage) Slirp_usage (6, 6, 0);
}

static void sl_absfnc (void)
{
   double retval;
   double arg1;
   void* arg2;
   Slirp_Opaque* arg2_o = NULL;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_opaque(void_ptr_Type, (void**)&arg2, &arg2_o)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = absfnc( arg1, arg2);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_2:
   SLang_free_opaque(arg2_o);
usage_label:
   if (issue_usage) Slirp_usage (7, 7, 0);
}

static void sl_comint (void)
{
   double retval;
   double arg1;
   void* arg2;
   Slirp_Opaque* arg2_o = NULL;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_opaque(void_ptr_Type, (void**)&arg2, &arg2_o)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = comint( arg1, arg2);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_2:
   SLang_free_opaque(arg2_o);
usage_label:
   if (issue_usage) Slirp_usage (8, 8, 0);
}

static void sl_bbearth (void)
{
   double retval;
   double arg1;
   void* arg2;
   Slirp_Opaque* arg2_o = NULL;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_opaque(void_ptr_Type, (void**)&arg2, &arg2_o)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = bbearth( arg1, arg2);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_2:
   SLang_free_opaque(arg2_o);
usage_label:
   if (issue_usage) Slirp_usage (9, 9, 0);
}

static void sl_bbfnc (void)
{
   double retval;
   double arg1;
   void* arg2;
   Slirp_Opaque* arg2_o = NULL;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_opaque(void_ptr_Type, (void**)&arg2, &arg2_o)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = bbfnc( arg1, arg2);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_2:
   SLang_free_opaque(arg2_o);
usage_label:
   if (issue_usage) Slirp_usage (10, 10, 0);
}

static void sl_bbdisk (void)
{
   double retval;
   double arg1;
   double arg2;
   double arg3;
   double arg4;
   double arg5;
   double arg6;
   double arg7;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 7) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg7)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg6)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg5)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg4)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg3)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg2)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   retval = bbdisk( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (11, 11, 0);
}

static void sl_synint (void)
{
   double arg1;
   double arg2;
   double arg3;
   double arg4;
   double arg5;
   double arg6;
   double arg7;
   double arg8;
   double arg9;
   double arg10;
   double arg11;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 11) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg11)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg10)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg9)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg8)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg7)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg6)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg5)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg4)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg3)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg2)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   synint( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (12, 12, 0);
}

static void sl_equipartition (void)
{
   double arg1;
   double arg2;
   int arg3;
   double arg4;
   double arg5;
   double arg6;
   double arg7;
   double arg8;
   double arg9;
   double arg10;
   double arg11;
   double arg12;
   double arg13;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 13) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg13)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg12)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg11)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg10)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg9)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg8)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg7)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg6)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg5)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg4)) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg3)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg2)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   equipartition( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11,  arg12,  arg13);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (13, 13, 0);
}

static void sl_bbfnc3 (void)
{
   double retval;
   double arg1;
   void* arg2;
   Slirp_Opaque* arg2_o = NULL;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_opaque(void_ptr_Type, (void**)&arg2, &arg2_o)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = bbfnc3( arg1, arg2);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_2:
   SLang_free_opaque(arg2_o);
usage_label:
   if (issue_usage) Slirp_usage (14, 14, 0);
}

static void sl_k0_fnc (void)
{
   double retval;
   double arg1;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   retval = k0_fnc( arg1);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (15, 15, 0);
}

static void sl_bljetpars (void)
{
   double arg1;
   double arg2;
   double arg3;
   double arg4;
   double arg5;
   double arg6;
   double arg7;
   double arg8;
   double arg9;
   double arg10;
   double arg11;
   double arg12;
   double arg13;
   double arg14;
   double arg15;
   double arg16;
   gsl_spline* arg17;
   Slirp_Opaque* arg17_o = NULL;
   gsl_interp_accel* arg18;
   Slirp_Opaque* arg18_o = NULL;
   double arg19;
   double arg20;
   double arg21;
   double arg22;
   double arg23;
   double arg24;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 24) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg24)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg23)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg22)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg21)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg20)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg19)) goto usage_label;
   if (-1 == SLang_pop_opaque(gsl_interp_accel_ptr_Type, (void**)&arg18, &arg18_o)) goto usage_label;
   if (-1 == SLang_pop_opaque(gsl_spline_ptr_Type, (void**)&arg17, &arg17_o)) goto free_and_return_18;
   if (-1 == SLang_pop_double((double*)&arg16)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg15)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg14)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg13)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg12)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg11)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg10)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg9)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg8)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg7)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg6)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg5)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg4)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg3)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg2)) goto free_and_return_17;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_17;
   issue_usage = 0;

   bljetpars( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11,  arg12,  arg13,  arg14,  arg15,  arg16, arg17, arg18,  arg19,  arg20,  arg21,  arg22,  arg23,  arg24);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_17:
   SLang_free_opaque(arg17_o);
free_and_return_18:
   SLang_free_opaque(arg18_o);
usage_label:
   if (issue_usage) Slirp_usage (16, 16, 0);
}

static void sl_enden (void)
{
   double retval;
   double arg1;
   double arg2;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg2)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   retval = enden( arg1,  arg2);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (17, 17, 0);
}

static void sl_bbdiskfnc (void)
{
   double retval;
   double arg1;
   void* arg2;
   Slirp_Opaque* arg2_o = NULL;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_opaque(void_ptr_Type, (void**)&arg2, &arg2_o)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = bbdiskfnc( arg1, arg2);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_2:
   SLang_free_opaque(arg2_o);
usage_label:
   if (issue_usage) Slirp_usage (18, 18, 0);
}

static void sl_k1_fnc (void)
{
   double retval;
   double arg1;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   retval = k1_fnc( arg1);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (19, 19, 0);
}

static void sl_comfnc (void)
{
   double retval;
   double arg1;
   void* arg2;
   Slirp_Opaque* arg2_o = NULL;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_opaque(void_ptr_Type, (void**)&arg2, &arg2_o)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = comfnc( arg1, arg2);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_2:
   SLang_free_opaque(arg2_o);
usage_label:
   if (issue_usage) Slirp_usage (20, 20, 0);
}

static void sl_bbearthint (void)
{
   double arg1;
   double arg2;
   double arg3;
   double arg4;
   double arg5;
   double arg6;
   double arg7;
   double arg8;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 8) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg8)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg7)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg6)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg5)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg4)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg3)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg2)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto usage_label;
   issue_usage = 0;

   bbearthint( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (21, 21, 0);
}

static void sl_synemis (void)
{
   double retval;
   double arg1;
   void* arg2;
   Slirp_Opaque* arg2_o = NULL;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_opaque(void_ptr_Type, (void**)&arg2, &arg2_o)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = synemis( arg1, arg2);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_2:
   SLang_free_opaque(arg2_o);
usage_label:
   if (issue_usage) Slirp_usage (22, 22, 0);
}

static void sl_comintegral (void)
{
   double retval;
   double arg1;
   double arg2;
   double arg3;
   double arg4;
   double arg5;
   gsl_spline* arg6;
   Slirp_Opaque* arg6_o = NULL;
   gsl_interp_accel* arg7;
   Slirp_Opaque* arg7_o = NULL;
   gsl_spline* arg8;
   Slirp_Opaque* arg8_o = NULL;
   gsl_interp_accel* arg9;
   Slirp_Opaque* arg9_o = NULL;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 9) goto usage_label;
   if (-1 == SLang_pop_opaque(gsl_interp_accel_ptr_Type, (void**)&arg9, &arg9_o)) goto usage_label;
   if (-1 == SLang_pop_opaque(gsl_spline_ptr_Type, (void**)&arg8, &arg8_o)) goto free_and_return_9;
   if (-1 == SLang_pop_opaque(gsl_interp_accel_ptr_Type, (void**)&arg7, &arg7_o)) goto free_and_return_8;
   if (-1 == SLang_pop_opaque(gsl_spline_ptr_Type, (void**)&arg6, &arg6_o)) goto free_and_return_7;
   if (-1 == SLang_pop_double((double*)&arg5)) goto free_and_return_6;
   if (-1 == SLang_pop_double((double*)&arg4)) goto free_and_return_6;
   if (-1 == SLang_pop_double((double*)&arg3)) goto free_and_return_6;
   if (-1 == SLang_pop_double((double*)&arg2)) goto free_and_return_6;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_6;
   issue_usage = 0;

   retval = comintegral( arg1,  arg2,  arg3,  arg4,  arg5, arg6, arg7, arg8, arg9);
   (void)SLang_push_double(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_6:
   SLang_free_opaque(arg6_o);
free_and_return_7:
   SLang_free_opaque(arg7_o);
free_and_return_8:
   SLang_free_opaque(arg8_o);
free_and_return_9:
   SLang_free_opaque(arg9_o);
usage_label:
   if (issue_usage) Slirp_usage (23, 23, 0);
}

static void sl_synintegrals (void)
{
   double arg1;
   double arg2;
   double arg3;
   double arg4;
   gsl_spline* arg5;
   Slirp_Opaque* arg5_o = NULL;
   gsl_interp_accel* arg6;
   Slirp_Opaque* arg6_o = NULL;
   gsl_spline* arg7;
   Slirp_Opaque* arg7_o = NULL;
   gsl_interp_accel* arg8;
   Slirp_Opaque* arg8_o = NULL;
   gsl_spline* arg9;
   Slirp_Opaque* arg9_o = NULL;
   gsl_interp_accel* arg10;
   Slirp_Opaque* arg10_o = NULL;
   double arg11;
   double arg12;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 12) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg12)) goto usage_label;
   if (-1 == SLang_pop_double((double*)&arg11)) goto usage_label;
   if (-1 == SLang_pop_opaque(gsl_interp_accel_ptr_Type, (void**)&arg10, &arg10_o)) goto usage_label;
   if (-1 == SLang_pop_opaque(gsl_spline_ptr_Type, (void**)&arg9, &arg9_o)) goto free_and_return_10;
   if (-1 == SLang_pop_opaque(gsl_interp_accel_ptr_Type, (void**)&arg8, &arg8_o)) goto free_and_return_9;
   if (-1 == SLang_pop_opaque(gsl_spline_ptr_Type, (void**)&arg7, &arg7_o)) goto free_and_return_8;
   if (-1 == SLang_pop_opaque(gsl_interp_accel_ptr_Type, (void**)&arg6, &arg6_o)) goto free_and_return_7;
   if (-1 == SLang_pop_opaque(gsl_spline_ptr_Type, (void**)&arg5, &arg5_o)) goto free_and_return_6;
   if (-1 == SLang_pop_double((double*)&arg4)) goto free_and_return_5;
   if (-1 == SLang_pop_double((double*)&arg3)) goto free_and_return_5;
   if (-1 == SLang_pop_double((double*)&arg2)) goto free_and_return_5;
   if (-1 == SLang_pop_double((double*)&arg1)) goto free_and_return_5;
   issue_usage = 0;

   synintegrals( arg1,  arg2,  arg3,  arg4, arg5, arg6, arg7, arg8, arg9, arg10,  arg11,  arg12);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_5:
   SLang_free_opaque(arg5_o);
free_and_return_6:
   SLang_free_opaque(arg6_o);
free_and_return_7:
   SLang_free_opaque(arg7_o);
free_and_return_8:
   SLang_free_opaque(arg8_o);
free_and_return_9:
   SLang_free_opaque(arg9_o);
free_and_return_10:
   SLang_free_opaque(arg10_o);
usage_label:
   if (issue_usage) Slirp_usage (24, 24, 0);
}


static SLang_Intrin_Fun_Type agnjet_merged_Funcs [] =
{
   MAKE_INTRINSIC_0((char*)"k3_fnc",sl_k3_fnc,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"xrbjet",sl_xrbjet,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"k2_fnc",sl_k2_fnc,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"bbintegrals",sl_bbintegrals,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"xrbinterp",sl_xrbinterp,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"b_prof",sl_b_prof,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"jetpars",sl_jetpars,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"absfnc",sl_absfnc,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"comint",sl_comint,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"bbearth",sl_bbearth,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"bbfnc",sl_bbfnc,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"bbdisk",sl_bbdisk,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"synint",sl_synint,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"equipartition",sl_equipartition,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"bbfnc3",sl_bbfnc3,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"k0_fnc",sl_k0_fnc,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"bljetpars",sl_bljetpars,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"enden",sl_enden,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"bbdiskfnc",sl_bbdiskfnc,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"k1_fnc",sl_k1_fnc,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"comfnc",sl_comfnc,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"bbearthint",sl_bbearthint,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"synemis",sl_synemis,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"comintegral",sl_comintegral,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"synintegrals",sl_synintegrals,SLANG_VOID_TYPE),
   SLANG_END_INTRIN_FUN_TABLE
};   /* }}} */

static const char* usage_strings[] = { /* {{{ */
   "double = k3_fnc(double)",
   "xrbjet(double[],int,double[],double[],double[])",
   "double = k2_fnc(double)",
   "bbintegrals(double,double,double,double,double,double,double,double,double)",
   "xrbinterp(double[],double[],double[],double[],int,int)",
   "b_prof(double,double,double,double,double,double,double,double,double,double,double,double,double)",
   "jetpars(double,double,double,double,double,double,double,double,double,double,double,gsl_spline_ptr,gsl_interp_accel_ptr,double,double,double,double,double,double)",
   "double = absfnc(double,void_ptr)",
   "double = comint(double,void_ptr)",
   "double = bbearth(double,void_ptr)",
   "double = bbfnc(double,void_ptr)",
   "double = bbdisk(double,double,double,double,double,double,double)",
   "synint(double,double,double,double,double,double,double,double,double,double,double)",
   "equipartition(double,double,int,double,double,double,double,double,double,double,double,double,double)",
   "double = bbfnc3(double,void_ptr)",
   "double = k0_fnc(double)",
   "bljetpars(double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,gsl_spline_ptr,gsl_interp_accel_ptr,double,double,double,double,double,double)",
   "double = enden(double,double)",
   "double = bbdiskfnc(double,void_ptr)",
   "double = k1_fnc(double)",
   "double = comfnc(double,void_ptr)",
   "bbearthint(double,double,double,double,double,double,double,double)",
   "double = synemis(double,void_ptr)",
   "double = comintegral(double,double,double,double,double,gsl_spline_ptr,gsl_interp_accel_ptr,gsl_spline_ptr,gsl_interp_accel_ptr)",
   "synintegrals(double,double,double,double,gsl_spline_ptr,gsl_interp_accel_ptr,gsl_spline_ptr,gsl_interp_accel_ptr,gsl_spline_ptr,gsl_interp_accel_ptr,double,double)",
NULL
}; /* }}} */

static void Slirp_usage(int i, int last, int flags) /* {{{ */
{
   char *indent;
   int npop = SLstack_depth();
   if (npop > SLang_Num_Function_Args) npop = SLang_Num_Function_Args;
   SLdo_pop_n(npop);
   if (last == i)
	indent = (char*)"Usage:  ";
   else {
	indent = (char*)"\t";
	SLang_verror(SL_USAGE_ERROR, (char*)"Usage: one of");
   }
   do
	SLang_verror(SL_USAGE_ERROR, (char*)"%s%s", indent, usage_strings[i++]);
   while (i < last);
   if (flags & 0x2)
	SLang_verror(SL_USAGE_ERROR,
		(char*)"\tThis function has been vectorized and parallelized.");
   else if (flags & 0x1)
	SLang_verror(SL_USAGE_ERROR, (char*)"\tThis function has been vectorized.");
} /* }}} */

static SLang_IConstant_Type agnjet_merged_IConsts [] =	/* {{{ */
{
   MAKE_ICONSTANT((char*)"precision",30),
   MAKE_ICONSTANT((char*)"NEBIN",10000),
   MAKE_ICONSTANT((char*)"NR_END",1),
   MAKE_ICONSTANT((char*)"SIZEMAX",10000),
   SLANG_END_ICONST_TABLE
};	/* }}} */

static SLang_DConstant_Type agnjet_merged_DConsts [] =	/* {{{ */
{
   MAKE_DCONSTANT((char*)"mjy",1.e-26),
   MAKE_DCONSTANT((char*)"kboltz_kev",8.617e-8),
   MAKE_DCONSTANT((char*)"charg",4.8e-10),
   MAKE_DCONSTANT((char*)"aconst",7.56e-15),
   MAKE_DCONSTANT((char*)"re0",2.81794e-13),
   SLANG_END_DCONST_TABLE
};	/* }}} */

BEGIN_DECLS
#define SLIRP_VERSION_STRING pre2.0.0-31
#define SLIRP_VERSION_NUMBER 20000
SLANG_MODULE(agnjet_merged);
int init_agnjet_merged_module_ns(char *ns_name)	/* {{{ */
{
   SLang_NameSpace_Type *ns = NULL;

   if (slang_abi_mismatch()) return -1;
   if (ns_name != NULL) {
	ns = SLns_create_namespace (ns_name);
       if (ns == NULL ||
          (slns = SLmalloc(strlen(ns_name)+1)) == NULL)
          return -1;
       strcpy(slns, ns_name);
   }

   (void) &ref_get_size; /* avoid compile warn if unused */

   if (allocate_reserved_opaque_types() == -1) return -1;
   if (allocate_agnjet_merged_opaque_types() == -1) return -1;

#ifdef HAVE_OPAQUE_IVARS
   if (-1 == set_opaque_ivar_types(agnjet_merged_Opaque_IVars) ||
       -1 == SLns_add_intrin_var_table(ns,agnjet_merged_Opaque_IVars,NULL))
	return -1;
#endif

   if ( -1 == SLns_add_iconstant_table(ns,agnjet_merged_IConsts,NULL) ||
	-1 == SLns_add_dconstant_table(ns,agnjet_merged_DConsts,NULL) ||
	-1 == SLns_add_intrin_fun_table (ns,agnjet_merged_Funcs,(char*)"__agnjet_merged__"))
	return -1;

   return 0;
} /* }}} */
END_DECLS
