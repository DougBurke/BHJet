---------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------

The High Energy astRophysics rEaSonable code librarY - HERESY - is a group of c++ classes designed to solve common problems in high energy astrophysics. It currently includes several classes inherited from two general classes - particle.hpp and radiation.hpp. The first one deals with particle distributions, the second with radiative mechanisms as well as spectral components commonly found in astrophysical sources. Currently the only radiating particles supported are leptons; hadrons will be included in the near/intermediate future. Every other class in the library is inherited from these either one of these two classes. 
 
---------------------------------------------------------------------------------------------------------------------------------------

Particle distributions:
These classes are designed to treat both non-relativistic and relativistic particle distributions. This requires the particle distributions to be written in units of momentum, and the number density to be particles per unit volume, per unit momentum. The class also automatically initializes and calculates the distribution in Lorentz factor space - the Lorentz factor is calculated from the particle momentum, and the corresponding number density is written in units of particles per unit volume, per unit Lorentz factor. One important point in using all of these classes is that, before setting the number densities with the .set_ndens() member, one needs to set the normalization of the particle distribution by using the .set_norm(n) member. This method requires knowing n, the total number density per unit volume of particles, in advance. The functions used to integrate the particle distributions are friend members; this allows the functions to access the protected and private members of the class, and to also have the correct input parameters (a double and a void pointer) for integrating with the GSL libraries. The classes that share this structure are:

- Particles
This is the prototype class for all distributions; it containes basic methods to manipulate and test arrays that are common and shared between all distributions, as well as a generalised class destructor.

- Thermal
This distribution follows a Maxwell-Juttner distribution in momentum space, and can treat both relativistic temperatures (> 511 keV) and non-relativistic temperatures down to ~1 keV. Below this threshold, the normalization of the M-J distribution diverges due to numerical errors, and the number density array returns only nan. This class does not contain methods to solve the continuity equation, as it makes no sense to do so if one assumes the distribution is thermalized in the first place.

- Powerlaw
This distribution follows a N0*p^(-s) power-law distribution in momentum space; for large values of p, it reduces to a standard power-law distribution in Lorentz factor space as well. The constructor requires, in order: an integer specifying the size of the arrays used, an integer specifying the type of particle (lepton or hadron), the index of the power-law, and a boolean flag which should be set to 0/false if one does not intend to calculate the equilibrium cooled distribution before computing the radiation from the distribution, and to 1/true otherwise.  

- Bknpower  
This distribution follows a smoothly broken power-law distribution in momentum space; for large values of p, it reduces to a standard broken power-law distribution in Lorentz factor (e.g. Ghisellini et al. 2009) space as well. The constructor requires, in order: an integer specifying the size of the arrays used, an integer specifying the type of particle (lepton or hadron), the two indexes before and after the break in the distribution, and a boolean flag which should be set to 0/false if one does not intend to calculate the equilibrium cooled distribution before computing the radiation from the distribution, and to 1/true otherwise.  

- Kappa 
This distribution follows a k-distribution in Lorentz factor space (e.g. Develaar et al. 2017), which is then converted in the appropriate distribution in momentum space; the k- distribution roughly mimics a Maxwell-Juttner distribution with a power-law tail of slope k+1, where k is the index that defines the Kappa distribution. The constructor requires, in order: an integer specifying the size of the arrays used, an integer specifying the type of particle (lepton or hadron), the temperature of the particles, the k-index, and a boolean flag which should be set to 0/false if one does not intend to calculate the equilibrium cooled distribution before computing the radiation from the distribution, and to 1/true otherwise.  

- Mixed 
This distribution follows a hybrid thermal/non-thermal distribution, as traditionally done in the agnjet model (e.g. Markoff et al. 2001, 2005). The ratio of non-thermal to thermal particles is set by the .set_plfrac(f) method; a fraction f is assumed to be non-thermal and follows the same distribution and methods as the Powerlaw class, while the remaining fraction 1-f is thermal (and is therefore treated identically to the Thermal.hpp class). The constructor requires, in order: an integer specifying the size of the arrays used, an integer specifying the type of particle (lepton or hadron), the temperature of the particles, the index of the power-law, and a boolean flag which should be set to 0/false if one does not intend to calculate the equilibrium cooled distribution before computing the radiation from the distribution, and to 1/true otherwise.  

The classes powerlaw, bknpower, kappa and mixed all have methods to both set the maximum momentum of the particles, and solve the steady-state continuity equation, for a given set of physical conditions in the source. The .set_p() method allows one to set the maximum momentum of the distribution by comparing the acceleration and cooling time-scales (including adiabatic cooling, synchrotron cooling, and inverse Compton cooling, and neglectic Klein-Nishina effects). Alternatively, it is possible to simply specify a desired maximum Lorentz factor in each distribution. The .cooling_steadystate() method allows one to solve the continuity equation assuming continuous injection of particles, and knowing the adiabatic and radiative timescales loss terms in the source (neglecting Klein-Nishina effects as the .set_p() method). 

---------------------------------------------------------------------------------------------------------------------------------------

Radiative mechanisms:
These classes are designed to calculate the emission of spectral components commonly found in the SEDs of high energy sources. These can either be related to particle distributions (e.g. cyclosynchrotron, inverse Compton), but that need not be the case (e.g. black body, accretion disk). Each class always uses two different sets of arrays; one in the comoving frame of the source (en_phot, num_phot), and one in the observer frame (en_phot_obs, num_phot_obs), automatically accounting for viewing angle and Doppler boosting effects, but not for cosmological redshift. The energy of the photons is always expressed in erg, and the luminosity for each energy bin is expressed in erg/s/Hz.

- Radiation
This is the prototype class for all the spectral components treated; it containes basic methods to manipulate and test arrays that are common and shared between all classes. Note that before calculating the spectra one needs to set the geometry of the source (assumed to be homogeneous); the only exception to this is the ShSDisk class, which assumes a Shakura-Sunyaev type disk and therefore sets the geometry internally. It is also possible to include the presence of both an approaching and receding source (effectively, a counterjet) with different Lorentz factors; the class does so by extending the size of the _obs arrays. 

- BBody 
This class calculates the emission from a thermalized, optically thick source emitting black body radiation of given temperature (in Kelvin or keV) and luminosity (in erg/s). It is also possible to return the energy density seen by an observer standing at rest, at a distance d from the source. The constructor requires the temperature of the black body in keV and the luminosity in erg/s and sets the size of the arrays automatically.
 
- ShSDisk
This class treats a truncated, optically thick, geometrically thin, Shakura-Sunyaev type disk. The disk is assumed to be truncated at a distance Rin (expressed in Rg); at this distance, it is possible to either define the temperature and calculated the corresponding luminosity, or vice versa, through the constructor. The scale height H/R of the disk is assumed to be max(0.1,L), where L is the luminosity in Eddington units, H the disk height, and R the disk radius. H/R is therefore constant throughout the disk, and the farther away one moves from the central engine, the thicker the disk gets in units of Rg. This behavior physically roughly mimics the Shakura-Sunyaev model (Shakura and Sunyaev 1973): for low (<10% Eddington) accretion rates H/R is driven by the viscosity alpha parameter (whose value is typically 0.1), but for higher accretion rates radiation pressure can start puffing up the disk. Note that this is NOT a self-consistent treatement of a slim disk model. The constructor requires a boolean flag to choose between defining the inner radius and luminosity or inner radius and temperature, the mass of the central black hole, the temperature or luminosity of the disk (depending on the value of the first boolean) at the inner radius, the inner radius of the disk in Rg, and the outer radius of the disk in Rg. The size of the arrays is set automatically.

- Cyclosyn
This class calculates the cyclosynchrotron emission from a population of particles in both the relativistic and non-relativistic regime.  The emissivity for the non-relativistic regime is the phenomenlogical treatement of Petrosian (1981), while in the relativistic regime the treatement is that of Bloumethal and Gould (1970). Before running the calculations, one needs to specify the magnetic field with the .set_bfield() method. The absorption coefficient is calculated by integrating by parts - therefore, one needs to know the differential of the particle distribution. In order to calculate the spectrum one needs to call the .cycsyn_spectrum() method, which requires knowledge of the minimum and maximum Lorentz factor of the particle distribution, as well as both the electron distribution and its differential in Lorentz factor units. The latter two need to be gsl_spline objects. The constructor requires an integer defining the size of the en_phot arrays, the minimum and maximum frequencies over which the spectrum is to be computed, as well as the mass of the emitting particles.

- Compton 
This class calculates the inverse Compton emission from a population of particles in both the relativistic and non-relativistic regime. In both cases, the calculations are found in Bloumethal and Gould (1970). The code accounts both for Klein-Nishina effects as well as multiple scatters, and is optimized for optical depths of up to ~a few in order to probe X-ray coronae of accreting black holes. There are two important notes on using this class in the multiple scatter regime. Frist, this class is the most computationally expensive of the library, especially in the case of multiple scatters. Second, the code automatically recognizes when the photon to be scattered has more energy than the electron doing the scattering. Therefore specifying the exact number of scatters physically happening is not necessary; typically, using more than ~15 scatters slows down the code without any change to the spectrum. Different seed fields can be used. It is possible to calculate SSC emission, using the en_phot and num_phot arrays from the Cyclosyn class, or to scatter black body photons (described by an energy density in erg/cm and a temperature in keV), or to scatter disk photons in a lamp-post geometry (described by a disk temperature in Kelvin, an inner and outer radius in Rg, a scale height h, at a distance z -in Rg- from the disk). The constructor requires an integer defining the size of the en_phot arrays, an integer to define the size of the seed photon field array, an integer to define the number of scatters to be calculated, the minimum and maximum frequencies over which to calculate the spectrum, and the mass of the scattering particles.

---------------------------------------------------------------------------------------------------------------------------------------
